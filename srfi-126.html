<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>R6RS-based hashtables</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="http://srfi.schemers.org/srfi.css" type="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="header">
<h1 class="title">R6RS-based hashtables</h1>
</div>
<h2 id="author">Author</h2>
<p>Taylan Ulrich Bayırlı/Kammer, taylanbayirli at Google Mail</p>
<h2 id="status">Status</h2>
<p>This SRFI is currently in <em>draft</em> status. Here is <a href="http://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold. To provide input on this SRFI, please send email to <code><a href="mailto:srfi minus 126 at srfi dot
schemers dot org">srfi-126@<span
class="antispam">nospam</span>srfi.schemers.org</a></code>. To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>. You can access previous messages via the mailing list <a href="http://srfi-email.schemers.org/srfi-126">archive</a>.</p>
<ul>
<li>Received: 2015/9/8</li>
<li>Draft #1 published: 2015/9/8</li>
<li>Draft #2 published: 2015/9/9</li>
</ul>
<h2 id="abstract">Abstract</h2>
<p>We provide a hashtable API that takes the R6RS hashtables API as a basis and makes backwards compatible additions such as support for weak hashtables, external representation, and utility procedures.</p>
<h2 id="rationale">Rationale</h2>
<p>This specification provides an alternative to SRFI-125. It builds on the R6RS hashtables API instead of SRFI-69, with only fully backwards compatible additions, most notably weak and ephemeral hashtables, and external representation. Other additions are limited to utility procedures, whose criteria for inclusion are that they be:</p>
<ul>
<li>used frequently in typical user code, or</li>
<li>nontrivial to define or imitate when needed, or</li>
<li>essential for the efficient implementation of further operations.</li>
</ul>
<p>There is &quot;full&quot; backwards compatibility in the sense that all R6RS hashtable operations within a piece of code that execute without raising exceptions will continue to execute without raising exceptions when the hashtable library in use is changed to an implementation of this specification. On the other hand, R6RS's stark requirement of raising an exception when a procedure's use does not exactly correspond to the description in R6RS (which effectively prohibits extensions to its procedures' semantics) is ignored.</p>
<p>The R6RS hashtables API is favored over SRFI-69 because the latter contains serious flaws. In particular, exposing the hash functions for the <code>eq?</code> and <code>eqv?</code> procedures is a hindrance for Scheme implementations with a moving garbage collector. SRFI-125 works around this by allowing the user-provided hash function passed to <code>make-hash-table</code> to be ignored by the implementation, and allowing the <code>hash-table-hash-function</code> procedure to return <code>#f</code> instead of the hash function passed to <code>make-hash-table</code>. R6RS avoids the issue by providing dedicated constructors for <code>eq?</code> and <code>eqv?</code> based hashtables, and returning <code>#f</code> when their hash function is queried.</p>
<p>This specification also does not depend on SRFI-114 (Comparators), does not specify a spurious amount of utility procedures, does not describe a bimap API, and does not attempt to specify thread-safety because typical multi-threaded use-cases will most likely involve locking more than just accesses and mutations of hashtables.</p>
<p>The additions made by this specification to the R6RS hashtables API may be summarized as follows:</p>
<ul>
<li>Support for weak and ephemeral hashtables.</li>
<li>External representation for hashtables.</li>
<li>A triplet of <code>alist-&gt;hashtable</code> constructors.</li>
<li>The procedures <code>hashtable-lookup</code> and <code>hashtable-intern!</code>.</li>
<li>The procedure <code>hashtable-clear-copy</code>.</li>
<li>Addition of the missing <code>hashtable-values</code> procedure.</li>
<li>The procedures <code>hashtable-for-each</code>, <code>hashtable-map!</code>, <code>hashtable-prune!</code>, <code>hashtable-fold</code>, <code>hashtable-map-&gt;list</code>, <code>hashtable-find</code>, and <code>hashtable-search</code>.</li>
<li>The procedures <code>hashtable-key-list</code>, <code>hashtable-value-list</code>, and <code>hashtable-&gt;alist</code>.</li>
</ul>
<p>Additionally, this specification adheres to the R7RS rule of specifying a single return value for procedures which don't have meaningful return values.</p>
<h2 id="specification">Specification</h2>
<p>The <code>(srfi 126)</code> library provides a set of operations on hashtables. A hashtable is of a disjoint type that associates keys with values. Any object can be used as a key, provided a hash function and a suitable equivalence function is available. A hash function is a procedure that maps keys to exact integer objects. It is the programmer's responsibility to ensure that the hash function is compatible with the equivalence function, which is a procedure that accepts two keys and returns true if they are equivalent and <code>#f</code> otherwise. Standard hashtables for arbitrary objects based on the <code>eq?</code> and <code>eqv?</code> predicates (see R7RS section on “Equivalence predicates”) are provided. Also, hash functions for arbitrary objects, strings, and symbols are provided.</p>
<p>Hashtables can store their key, value, or key and value weakly. Storing an object weakly means that the storage location of the object does not count towards the total storage locations in the program which refer to the object, meaning the object can be reclaimed as soon as no non-weak storage locations referring to the object remain. Weakly stored objects referring to each other in a cycle will be reclaimed as well if none of them are referred to from outside the cycle. When a weakly stored object is reclaimed, associations in the hashtable which have the object as their key or value are deleted.</p>
<p>Hashtables can also store their key and value in ephemeral storage pairs. The objects in an ephemeral storage pair are stored weakly, but both protected from reclamation as long as there remain non-weak references to the first object from outside the ephemeral storage pair. In particular, an ephemeral-key hashtable (where the keys are the first objects in the ephemeral storage pairs), with an association mapping an element of a vector to the vector itself, may delete said association when no non-weak references remain to the vector nor its element in the rest of the program. If it were a weak-key hashtable, the reference to the key from within the vector would cyclically protect the key and value from reclamation, even when no non-weak references to the key and value remained from outside the hashtable. At the absence of such references between the key and value, ephemeral-key and ephemeral-value hashtables behave effectively equivalent to weak-key and weak-value hashtables.</p>
<p>An implementation may implement weak-key and weak-value hashtables as ephemeral-key and ephemeral-value hashtables.</p>
<p><em>Rationale:</em> While the semantics of weak-key and weak-value hashtables is undesired, their implementation might be more efficient than ephemeral-key and ephemeral-value hashtables.</p>
<p>Ephemeral-key-and-value hashtables use a pair of ephemeral storage pairs for each association: one where the key is the first object and one where the value is. This means that the key and value are protected from reclamation until no references remain to neither the key nor value from outside the hashtable. In contrast, a weak-key-and-value hashtable will delete an association as soon as either the key or value is reclaimed.</p>
<p>Support for all types of weak and ephemeral hashtables is optional, to aid in adoption of the SRFI by smaller Scheme implementations which would otherwise disregard the SRFI entirely.</p>
<p>This document uses the <code>hashtable</code> parameter name for arguments that must be hashtables, and the <code>key</code> parameter name for arguments that must be hashtable keys.</p>
<h3 id="constructors">Constructors</h3>
<ul>
<li><code>(make-eq-hashtable)</code> (procedure)</li>
<li><code>(make-eq-hashtable capacity)</code></li>
<li><code>(make-eq-hashtable capacity weakness)</code></li>
</ul>
<p>Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with <code>eq?</code>. If the <code>capacity</code> argument is provided and not <code>#f</code>, it must be an exact non-negative integer and the initial capacity of the hashtable is set to approximately <code>capacity</code> elements. The <code>weakness</code> argument, if provided, must be one of: <code>#f</code>, <code>weak-key</code>, <code>weak-value</code>, <code>weak-key-and-value</code>, <code>ephemeral-key</code>, <code>ephemeral-value</code>, and <code>ephemeral-key-and-value</code>, and determines the weakness or ephemeral status for the keys and values in the hashtable. All values other than <code>#f</code> are optional to support; the implementation should signal the user in an implementation-defined manner when an unsupported value is used.</p>
<ul>
<li><code>(make-eqv-hashtable)</code> (procedure)</li>
<li><code>(make-eqv-hashtable capacity)</code></li>
<li><code>(make-eqv-hashtable capacity weakness)</code></li>
</ul>
<p>Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with <code>eqv?</code>. The semantics of the optional arguments are as in <code>make-eq-hashtable</code>.</p>
<p>Booleans, characters, numbers, and symbols are never stored weakly or ephemerally in a hashtable returned by <code>make-eqv-hashtable</code>, regardless of its weakness attribute.</p>
<p><em>Rationale:</em> The possible allocation and reclamation of instances of these types is an implementation detail. Within the semantics of Scheme, they are considered eternally alive, because a new instance that is <code>eqv?</code> to a previously alive instance may be reallocated at any point in a program.</p>
<ul>
<li><code>(make-hashtable hash-function equiv)</code> (procedure)</li>
<li><code>(make-hashtable hash-function equiv capacity)</code></li>
<li><code>(make-hashtable hash-function equiv capacity weakness)</code></li>
</ul>
<p>If <code>hash-function</code> is <code>#f</code> and <code>equiv</code> is the <code>eq?</code> procedure, the semantics of <code>make-eq-hashtable</code> apply to the rest of the arguments. If <code>hash-function</code> is <code>#f</code> and <code>equiv</code> is the <code>eqv?</code> procedure, the semantics of <code>make-eqv-hashtable</code> apply to the rest of the arguments.</p>
<p>Otherwise, <code>hash-function</code> and <code>equiv</code> must be procedures. <code>Hash-function</code> should accept a key as an argument and should return a non-negative exact integer object. <code>Equiv</code> should accept two keys as arguments and return a single value. Neither procedure should mutate the hashtable returned by <code>make-hashtable</code>. The <code>make-hashtable</code> procedure returns a newly allocated mutable hashtable using <code>hash-function</code> as the hash function and <code>equiv</code> as the equivalence function used to compare keys. The semantics of the remaining arguments are as in <code>make-eq-hashtable</code> and <code>make-eqv-hashtable</code>.</p>
<p>Both <code>hash-function</code> and <code>equiv</code> should behave like pure functions on the domain of keys. For example, the <code>string-hash</code> and <code>string=?</code> procedures are permissible only if all keys are strings and the contents of those strings are never changed so long as any of them continues to serve as a key in the hashtable. Furthermore, any pair of keys for which <code>equiv</code> returns true should be hashed to the same exact integer objects by <code>hash-function</code>.</p>
<p><em>Note:</em> Hashtables are allowed to cache the results of calling the hash function and equivalence function, so programs cannot rely on the hash function being called for every lookup or update. Furthermore any hashtable operation may call the hash function more than once.</p>
<ul>
<li><code>(alist-&gt;eq-hashtable alist)</code> (procedure)</li>
<li><code>(alist-&gt;eq-hashtable capacity alist)</code></li>
<li><code>(alist-&gt;eq-hashtable capacity weakness alist)</code></li>
</ul>
<p>The semantics of this procedure can be described as:</p>
<pre><code>(let ((ht (make-eq-hashtable capacity weakness)))
  (for-each (lambda (entry)
              (hashtable-set! ht (car entry) (cdr entry)))
            alist)
  ht)</code></pre>
<p>where omission of the <code>capacity</code> and/or <code>weakness</code> arguments corresponds to their omission in the call to <code>make-eq-hashtable</code>.</p>
<ul>
<li><code>(alist-&gt;eqv-hashtable alist)</code> (procedure)</li>
<li><code>(alist-&gt;eqv-hashtable capacity alist)</code></li>
<li><code>(alist-&gt;eqv-hashtable capacity weakness alist)</code></li>
</ul>
<p>This procedure is equivalent to <code>alist-&gt;eq-hashtable</code> except that <code>make-eqv-hashtable</code> is used to construct the hashtable.</p>
<ul>
<li><code>(alist-&gt;hashtable hash-function equiv alist)</code> (procedure)</li>
<li><code>(alist-&gt;hashtable hash-function equiv capacity alist)</code></li>
<li><code>(alist-&gt;hashtable hash-function equiv capacity weakness alist)</code></li>
</ul>
<p>This procedure is equivalent to <code>alist-&gt;eq-hashtable</code> except that <code>make-hashtable</code> is used to construct the hashtable, with the given <code>hash-function</code> and <code>equiv</code> arguments.</p>
<ul>
<li><code>(weakness &lt;weakness symbol&gt;)</code> (syntax)</li>
</ul>
<p>The <code>&lt;weakness symbol&gt;</code> must correspond to one of the non-<code>#f</code> values accepted for the <code>weakness</code> argument of the constructor procedures. Given such a symbol, it is returned as a datum. Passing any other argument is an error.</p>
<p><em>Rationale:</em> This allows for expand-time verification that a valid weakness attribute is specified.</p>
<h3 id="external-representation">External representation</h3>
<p>An implementation may optionally support external representations for the most common types of hashtables so that they can be read and written by and appear as constants in programs.</p>
<p><code>Eq?</code> and <code>eqv?</code> based hashtables are written using the notation <code>#hasheq(entry ...)</code> and <code>#hasheqv(entry ...)</code> respectively, where each <code>entry</code> must have the form <code>(key . value)</code>.</p>
<p>Hashtables using <code>equal-hash</code> as the hash function and <code>equal?</code> as the equivalence function may be written using the notation <code>#hash(entry ...)</code>. Other types of hashtables may be written using the notation <code>#hash(type entry ...)</code> where <code>type</code> must be one of: <code>string</code>, <code>string-ci</code>, and <code>symbol</code>. When <code>type</code> is <code>string</code>, the hashtable uses <code>string-hash</code> and <code>string=?</code> as the hash and equivalence function respectively. When <code>string-ci</code>, it uses <code>string-ci-hash</code> and <code>string-ci=?</code>. When <code>symbol</code>, it uses <code>symbol-hash</code> and <code>eq?</code>.</p>
<p>It is an error if any two keys in the list of entries are equivalent as per the equivalence function of the hashtable.</p>
<p>Hashtable constants are self-evaluating, meaning they do not need to be quoted in programs. The resulting hashtable must be immutable, and its weakness <code>#f</code>. The keys and values in the hashtable may be immutable.</p>
<h3 id="quasiquote">Quasiquote</h3>
<p>An implementation supporting external representation for hashtables may optionally extend <code>quasiquote</code> for hashtable constants.</p>
<p>When a hashtable constant appears within a quasiquote expression and is not already unquoted, the behavior of the quasiquote algorithm on the hashtable can be explained as follows:</p>
<pre><code>(let ((copy (hashtable-clear-copy hashtable #t)))
  (hashtable-for-each (lambda (key value)
                        (let ((key (apply-quasiquote key))
                              (value (apply-quasiquote value)))
                          (hashtable-set! copy key value)))
                      hashtable)
  ;; Make it immutable again.
  (hashtable-copy copy))</code></pre>
<p>where the procedure <code>apply-quasiquote</code> recursively applies the quasiquote algorithm to the key and value.</p>
<h3 id="procedures">Procedures</h3>
<ul>
<li><code>(hashtable? obj)</code> (procedure)</li>
</ul>
<p>Returns <code>#t</code> if <code>obj</code> is a hashtable, <code>#f</code> otherwise.</p>
<ul>
<li><code>(hashtable-size hashtable)</code> (procedure)</li>
</ul>
<p>Returns the number of keys contained in <code>hashtable</code> as an exact integer object.</p>
<ul>
<li><code>(hashtable-ref hashtable key default)</code> (procedure)</li>
</ul>
<p>Returns the value in <code>hashtable</code> associated with <code>key</code>. If <code>hashtable</code> does not contain an association for <code>key</code>, <code>default</code> is returned.</p>
<ul>
<li><code>(hashtable-set! hashtable key obj)</code> (procedure)</li>
</ul>
<p>Changes <code>hashtable</code> to associate <code>key</code> with <code>obj</code>, adding a new association or replacing any existing association for <code>key</code>, and returns an unspecified value.</p>
<ul>
<li><code>(hashtable-delete! hashtable key)</code> (procedure)</li>
</ul>
<p>Removes any association for <code>key</code> within <code>hashtable</code> and returns an unspecified value.</p>
<ul>
<li><code>(hashtable-contains? hashtable key)</code> (procedure)</li>
</ul>
<p>Returns <code>#t</code> if <code>hashtable</code> contains an association for <code>key</code>, <code>#f</code> otherwise.</p>
<ul>
<li><code>(hashtable-lookup hashtable key)</code> (procedure)</li>
</ul>
<p>Returns two values: the value in <code>hashtable</code> associated with <code>key</code> or an unspecified value if there is none, and a Boolean indicating whether an association was found.</p>
<ul>
<li><code>(hashtable-update! hashtable key proc default)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept one argument, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-update!</code> procedure applies <code>proc</code> to the value in <code>hashtable</code> associated with <code>key</code>, or to <code>default</code> if <code>hashtable</code> does not contain an association for <code>key</code>. The hashtable is then changed to associate <code>key</code> with the value returned by <code>proc</code>.</p>
<ul>
<li><code>(hashtable-intern! hashtable key default-proc)</code> (procedure)</li>
</ul>
<p><code>Default-proc</code> should accept zero arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-intern!</code> procedure returns the association for <code>key</code> in <code>hashtable</code> if there is one, otherwise it calls <code>default-proc</code> with zero arguments, associates its return value with <code>key</code> in <code>hashtable</code>, and returns that value.</p>
<ul>
<li><code>(hashtable-copy hashtable)</code> (procedure)</li>
<li><code>(hashtable-copy hashtable mutable)</code></li>
<li><code>(hashtable-copy hashtable mutable weakness)</code></li>
</ul>
<p>Returns a copy of <code>hashtable</code>. If the <code>mutable</code> argument is provided and is true, the returned hashtable is mutable; otherwise it is immutable. If the optional <code>weakness</code> argument is provided, it determines the weakness of the copy, otherwise the weakness attribute of <code>hashtable</code> is used.</p>
<ul>
<li><code>(hashtable-clear! hashtable)</code> (procedure)</li>
<li><code>(hashtable-clear! hashtable capacity)</code></li>
</ul>
<p>Removes all associations from <code>hashtable</code> and returns an unspecified value. If <code>capacity</code> is provided and not <code>#f</code>, it must be an exact non-negative integer and the current capacity of the hashtable is reset to approximately <code>capacity</code> elements.</p>
<ul>
<li><code>(hashtable-clear-copy hashtable)</code></li>
<li><code>(hashtable-clear-copy hashtable capacity)</code></li>
</ul>
<p>Returns a newly allocated mutable hashtable that has the same hash and equivalence functions and weakness attribute as <code>hashtable</code>. The <code>capacity</code> argument may be <code>#t</code> to set the initial capacity of the copy to approximately <code>(hashtable-size hashtable)</code> elements; otherwise the semantics of <code>make-eq-hashtable</code> apply to the <code>capacity</code> argument.</p>
<ul>
<li><code>(hashtable-keys hashtable)</code> (procedure)</li>
</ul>
<p>Returns a vector of all keys in <code>hashtable</code>. The order of the vector is unspecified.</p>
<ul>
<li><code>(hashtable-values hashtable)</code> (procedure)</li>
</ul>
<p>Returns a vector of all values in <code>hashtable</code>. The order of the vector is unspecified, and is not guaranteed to match the order of keys in the result of <code>hashtable-keys</code>.</p>
<ul>
<li><code>(hashtable-entries hashtable)</code> (procedure)</li>
</ul>
<p>Returns two values, a vector of the keys in <code>hashtable</code>, and a vector of the corresponding values.</p>
<p><em>Rationale:</em> Returning the keys and values as vectors allows for greater locality and less allocation than if they were returned as lists.</p>
<ul>
<li><code>(hashtable-for-each proc hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, and should not mutate <code>hashtable</code>. The <code>hashtable-for-each</code> procedure applies <code>proc</code> once for every association in <code>hashtable</code>, passing it the key and value as arguments. The order in which <code>proc</code> is applied to the associations is unspecified. Return values of <code>proc</code> are ignored. <code>Hashtable-for-each</code> returns an unspecified value.</p>
<ul>
<li><code>(hashtable-map! proc hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-map!</code> procedure applies <code>proc</code> once for every association in <code>hashtable</code>, passing it the key and value as arguments, and changes the value of the association to the return value of <code>proc</code>. The order in which <code>proc</code> is applied to the associations is unspecified. <code>Hashtable-map!</code> returns an unspecified value.</p>
<ul>
<li><code>(hashtable-prune! proc hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-prune!</code> procedure applies <code>proc</code> once for every association in <code>hashtable</code>, passing it the key and value as arguments, and deletes the association if <code>proc</code> returns a true value. The order in which <code>proc</code> is applied to the associations is unspecified. <code>Hashtable-prune!</code> returns an unspecified value.</p>
<p><em>Rationale:</em> This procedure is provided in place of a typical &quot;filter&quot; and &quot;remove&quot; pair because the name &quot;remove&quot; may easily be confused with &quot;delete,&quot; and because the semantics of a mutative filtering operation, which is to select elements to keep and remove the rest, counters the human intuition of selecting elements to remove.</p>
<ul>
<li><code>(hashtable-fold proc init hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept three arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-fold</code> procedure accumulates a result by applying <code>proc</code> once for every association in <code>hashtable</code>, passing it as arguments: the key, the value, and the result of the previous application or <code>init</code> at the first application. The order in which <code>proc</code> is applied to the associations is unspecified.</p>
<ul>
<li><code>(hashtable-map-&gt;list proc hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-map-&gt;list</code> procedure applies <code>proc</code> once for every association in <code>hashtable</code>, passing it the key and value as arguments, and accumulates the returned values into a list. The order in which <code>proc</code> is applied to the associations is unspecified.</p>
<ul>
<li><code>(hashtable-find proc hashtable default)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-find</code> procedure applies <code>proc</code> to associations in <code>hashtable</code> in an unspecified order until one of the applications returns a true value, which is then returned. If none of the applications return a true value, <code>default</code> is returned.</p>
<ul>
<li><code>(hashtable-search proc hashtable)</code> (procedure)</li>
</ul>
<p><code>Proc</code> should accept two arguments, should return a single value, and should not mutate <code>hashtable</code>. The <code>hashtable-search</code> procedure applies <code>proc</code> to associations in <code>hashtable</code> in an unspecified order until one of the applications returns a true value. Two values are returned: the true value returned by <code>proc</code> or an unspecified value if no applications of <code>proc</code> returned a true value, and a Boolean indicating whether any application returned a true value.</p>
<ul>
<li><code>(hashtable-key-list hashtable)</code> (procedure)</li>
</ul>
<p>Returns a list of all keys in <code>hashtable</code>. The order of the list is unspecified.</p>
<ul>
<li><code>(hashtable-value-list hashtable)</code> (procedure)</li>
</ul>
<p>Returns a list of all values in <code>hashtable</code>. The order of the list is unspecified, and is not guaranteed to match the order of keys in the result of <code>hashtable-key-list</code>.</p>
<ul>
<li><code>(hashtable-&gt;alist hashtable)</code> (procedure)</li>
</ul>
<p>Returns an alist mapping the keys in <code>hashtable</code> to their corresponding values.</p>
<p><em>Rationale:</em> Returning the keys and values as lists or an alist allows for using typical list processing idioms such as filtering and partitioning on the results. Additionally, these operations may be implemented more efficiently than their straightforward imitations using their vector-returning counterparts and <code>vector-&gt;list</code>.</p>
<h3 id="inspection">Inspection</h3>
<ul>
<li><code>(hashtable-equivalence-function hashtable)</code> (procedure)</li>
</ul>
<p>Returns the equivalence function used by <code>hashtable</code> to compare keys. For hashtables created with <code>make-eq-hashtable</code> and <code>make-eqv-hashtable</code>, returns <code>eq?</code> and <code>eqv?</code> respectively.</p>
<ul>
<li><code>(hashtable-hash-function hashtable)</code> (procedure)</li>
</ul>
<p>Returns the hash function used by <code>hashtable</code>. For hashtables created by <code>make-eq-hashtable</code> or <code>make-eqv-hashtable</code>, <code>#f</code> is returned.</p>
<ul>
<li><code>(hashtable-weakness hashtable)</code> (procedure)</li>
</ul>
<p>Returns the weakness attribute of <code>hashtable</code>. The same values that are accepted as the <code>weakness</code> argument in the constructor procedures are returned. This procedure may expose the fact that weak-key and weak-value hashtables are implemented as ephemeral-key and ephemeral-value hashtables, returning symbols indicating the latter even when the former were used to construct the hashtable.</p>
<ul>
<li><code>(hashtable-mutable? hashtable)</code> (procedure)</li>
</ul>
<p>Returns <code>#t</code> if <code>hashtable</code> is mutable, otherwise <code>#f</code>.</p>
<h3 id="hash-functions">Hash functions</h3>
<p>The <code>equal-hash</code>, <code>string-hash</code>, and <code>string-ci-hash</code> procedures of this section are acceptable as the hash functions of a hashtable only if the keys on which they are called are not mutated while they remain in use as keys in the hashtable.</p>
<ul>
<li><code>(equal-hash obj)</code> (procedure)</li>
</ul>
<p>Returns an integer hash value for <code>obj</code>, based on its structure and current contents. This hash function is suitable for use with <code>equal?</code> as an equivalence function.</p>
<p><em>Note:</em> Like <code>equal?</code>, the <code>equal-hash</code> procedure must always terminate, even if its arguments contain cycles.</p>
<ul>
<li><code>(string-hash string)</code> (procedure)</li>
</ul>
<p>Returns an integer hash value for <code>string</code>, based on its current contents. This hash function is suitable for use with <code>string=?</code> as an equivalence function.</p>
<ul>
<li><code>(string-ci-hash string)</code> (procedure)</li>
</ul>
<p>Returns an integer hash value for <code>string</code> based on its current contents, ignoring case. This hash function is suitable for use with <code>string-ci=?</code> as an equivalence function.</p>
<ul>
<li><code>(symbol-hash symbol)</code> (procedure)</li>
</ul>
<p>Returns an integer hash value for <code>symbol</code>.</p>
<h2 id="implementation">Implementation</h2>
<p>Larceny Scheme contains a portable implementation of the R6RS hashtables API as an R7RS library. It is included in the version control repository of this SRFI.</p>
<p>The alist constructors can be implemented trivially as seen in the piece of code describing their semantics. Here is a complete definition of <code>alist-&gt;eq-hashtable</code>:</p>
<pre><code>(define alist-&gt;eq-hashtable
  (case-lambda
    ((alist) (alist-&gt;eq-hashtable #f #f alist))
    ((capacity alist) (alist-&gt;eq-hashtable capacity #f alist))
    ((capacity weakness alist)
     (let ((ht (make-eq-hashtable capacity weakness)))
       (for-each (lambda (entry)
                   (hashtable-set! ht (car entry) (cdr entry)))
                 alist)
       ht))))</code></pre>
<p>The <code>hashtable-lookup</code> and <code>hashtable-intern!</code> procedures are trivial to implement, although it's desirable that they be implemented more efficiently at the platform level:</p>
<pre><code>(define (hashtable-lookup ht key)
  (if (hashtable-contains? key)
      (values (hashtable-ref ht key #f) #t)
      (values #f #f)))

(define (hashtable-intern! ht key default-proc)
  (if (hashtable-contains? key)
      (hashtable-ref ht key)
      (let ((value (default-proc)))
        (hashtable-set! ht key value)
        value)))</code></pre>
<p>The <code>hashtable-clear-copy</code> procedure can be implemented as follows:</p>
<pre><code>(define hashtable-clear-copy
  (case-lambda
    ((hashtable) (hashtable-clear-copy hashtable #f))
    ((hashtable capacity)
     (make-hashtable (hashtable-hash-function hashtable)
                     (hashtable-equivalence-function hashtable)
                     (if (eq? #t capacity)
                         (hashtable-size hashtable)
                         capacity)
                     (hashtable-weakness hashtable)))))</code></pre>
<p>The <code>hashtable-values</code>, <code>hashtable-for-each</code>, <code>hashtable-map!</code>, and <code>hashtable-prune!</code> procedures are simple to implement in terms of <code>hashtable-entries</code>, but it is desirable that they be implemented more efficiently at the platform level.</p>
<p>The <code>hashtable-fold</code> procedure could be implemented in terms of <code>hashtable-entries</code>, <code>vector-&gt;list</code>, and <code>fold</code>, but it is definitely desirable to implement it more efficiently. Given an efficient <code>hashtable-fold</code>, the following definitions can be used:</p>
<pre><code>(define (hashtable-map-&gt;list proc ht)
  (hashtable-fold &#39;()
                  (lambda (key value acc)
                    (cons (proc key value) acc))
                  ht))

(define (hashtable-key-list ht)
  (hashtable-map-&gt;list (lambda (key value) key) ht))

(define (hashtable-value-list ht)
  (hashtable-map-&gt;list (lambda (key value) value) ht))

(define (hashtable-&gt;alist ht)
  (hashtable-map-&gt;list cons ht))</code></pre>
<p>The <code>hashtable-find</code> and <code>hashtable-search</code> procedures are simple to implement in terms of <code>hashtable-entries</code>, but it is desirable that they be implemented more efficiently at the platform level. <code>Hashtable-find</code> can be implemented trivially in terms of an efficient <code>hashtable-search</code>.</p>
<p>Weak and ephemeral hashtables cannot be implemented by portable library code. They need to be implemented either directly at the platform level, or by using functionality which in turn needs to be implemented at the platform level, such as weak and ephemeral pairs. See MIT/GNU Scheme for an example.</p>
<p>External representation cannot be implemented by portable library code.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Thanks to Taylor Campbell and MIT/GNU Scheme for inspiring the idea of weak and ephemeral hashtables, some miscellaneous procedures, and overall input in the design of this SRFI.</p>
<h2 id="copyright-and-license">Copyright and license</h2>
<p>Copyright (C) Taylan Ulrich Bayırlı/Kammer (2015). All Rights Reserved.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</body>
</html>
